# Игровой цикл

Игровой цикл в ScrubJS обеспечивает непрерывное выполнение кода, подобно блоку `повторять всегда` в Scratch. Он позволяет "оживить" спрайты и сцены, задавая действия, которые будут выполняться с каждым кадром.

## Основная идея

Вместо прямого использования `requestAnimationFrame`, ScrubJS предоставляет удобные методы `forever`, `repeat` и `timeout` для управления игровым циклом.

```javascript
sprite.forever(() => {
    sprite.x += 1; // Спрайт двигается вправо каждый кадр
});
```
Эта функция будет автоматически вызываться при каждом обновлении экрана.

## Управление игровыми циклами

Методы `forever`, `repeat` и `timeout` доступны как для сцен (`Stage`), так и для спрайтов (`Sprite`), позволяя гибко настраивать логику обновления объектов.

### Forever: Непрерывное выполнение

`forever` запускает функцию, которая выполняется непрерывно, пока активна сцена или существует спрайт. Этот цикл идеально подходит для постоянных действий, таких как движение, анимация или проверка условий.

**Параметры:**

*   `callback`:  Функция, выполняемая на каждой итерации цикла.
*   `interval` (необязательный): Интервал в миллисекундах между выполнениями `callback`. Если не указан, функция выполняется при каждом кадре (максимально быстро).
*   `timeout` (необязательный): Задержка в миллисекундах перед *первым* запуском цикла.
*   `finishCallback` (необязательный): Функция, вызываемая *после* остановки цикла (например, при удалении спрайта).

### Repeat: Цикл с заданным количеством повторений

`repeat` запускает функцию, которая выполняется указанное количество раз.  Этот цикл подходит для действий, которые нужно выполнить несколько раз, например, для последовательности анимаций или повторяющихся эффектов.

**Параметры:**

*   `callback`: Функция, выполняемая на каждой итерации.
*   `repeat`: Количество повторений цикла.
*   `interval` (необязательный): Интервал в миллисекундах между итерациями. Если не указан, функция выполняется максимально быстро.
*   `timeout` (необязательный): Задержка перед *первым* запуском цикла.
*   `finishCallback` (необязательный): Функция, вызываемая после завершения цикла.

### Timeout: Однократное выполнение с задержкой

`timeout` выполняет функцию *один раз* после указанной задержки.  Этот цикл полезен для отложенных действий, например, для показа сообщения через некоторое время или для запуска эффекта после паузы.

**Параметры:**

*   `callback`: Функция, выполняемая после задержки.
*   `timeout`: Задержка в миллисекундах перед выполнением `callback`.

### Где использовать:

*   **Stage (Сцена):** Для глобальной логики игры, такой как управление фоном, создание эффектов или обработка ввода.
*   **Sprite (Спрайт):** Для логики, специфичной для конкретного спрайта, например, для его движения, анимации или взаимодействия с другими объектами.

**Важно:**

*   Все циклы автоматически останавливаются при смене сцены. При возврате на сцену циклы возобновляются.
*   При удалении спрайта все его активные циклы также автоматически останавливаются.

### Примеры:

```javascript
stage.forever(() => {
    console.log("Выполняется постоянно с частотой 100мс, первый запуск через 2 секунды.");
}, 100, 2000);

stage.repeat(() => {
    console.log("Выполнится 10 раз с частотой 200 мс. Первый запуск через 1 секунду.");
}, 10, 200, 1000, () => {
    console.log("Выполнится при завершении цикла.");
});

stage.timeout(() => {
    console.log("Выполнится один раз через 3 секунды.");
}, 3000);
```

## Контекст и управление состоянием цикла

### Контекст внутри цикла

Внутри функций, передаваемых в `forever`, `repeat` и `timeout`, доступны:

*   `this`: объект, к которому привязан цикл (сцена или спрайт);
*   `ScheduledState` (только для `forever` и `repeat`): объект позволяющий управлять циклом.

### ScheduledState: Управление циклом изнутри и снаружи

`ScheduledState` - это объект, возвращаемый при создании циклов `forever` и `repeat`, который предоставляет свойства для управления их выполнением.

**Свойства:**

*   `interval`: Интервал между итерациями в миллисекундах.
*   `maxIterations`:  Общее количество итераций для циклов `repeat`.
*   `currentIteration`:  Текущая итерация для циклов `repeat`.

### Примеры управления циклом:

```javascript
// Остановка цикла
stage.forever((stage, state) => {
    return false;
});

// Ускорение цикла
stage.forever((stage, state) => {
    state.interval -= 1;
});

// Передача параметров в цикл
const animationState = stage.forever((stage, state) => {
    player.nextCostume();
    
    if (state.control === 'fast') {
        state.interval = 100;
    }

    if (state.control === 'slow') {
        state.interval = 250;
    }

    if (state.control === 'stop') {
        return false;
    }
});

stage.forever(() => {
    if (game.keyPressed('d')) {
        animationState.control = 'fast';
    }
    
    if (game.keyPressed('a')) {
        animationState.control = 'slow';
    }
    
    if (game.keyPressed('space')) {
        animationState.control = 'stop';
    }
});
```

## Несколько циклов на один объект

Можно создавать несколько циклов для одного спрайта. Они будут выполняться независимо друг от друга, позволяя реализовать сложное поведение.

```javascript
sprite.forever(() => {
    sprite.x += 1; // Движение вправо
});

sprite.forever(() => {
    sprite.direction += 1; // Поворот
});
```

## Пример: Базовое управление игроком

```javascript
stage.forever(() => {
    if (game.keyPressed('d')) {
        sprite.x += 5; // Движение вправо при нажатии 'd'
    }
    
    if (game.keyPressed('a')) {
        sprite.x -= 5; // Движение влево при нажатии 'a'
    }
});
```

## Остановка всех циклов объекта

Для принудительной остановки всех циклов, связанных с объектом (спрайтом или сценой), используйте метод `stop()`:

```javascript
sprite.stop(); // Останавливает все циклы спрайта
```

## Как это работает

Все циклы (`forever`, `repeat` и `timeout`) регистрируются в системе управления временем ScrubJS.  В каждом кадре игры система вызывает функции обратного вызова (callback) этих циклов.  Вам не нужно управлять этим процессом вручную – всё происходит автоматически.
